asect 0x00

### Главная функция, которая выполняет перекладывание камней из данной лунки по 
### следующим лункам. А также обрабатывает специальные игровые правила.
MAKE_MOVE:
	ldi r0, 0x12        #оставили сообщение о том, что идёт распределение
	ldi r1, 0b00100000  #камней по лункам
	st r0, r1

	jsr LOAD_SEEDS_FROM_SELECTED_HOLE
	
	ldi r2, 0x08       #в r2 записали флаг, что нам нужна манкала врага
	jsr ONES_MANCALA   #в r0 положим манкалу, которую нужно пропускать
	while              #в r3 лежит номер лунки из которой был сделан ход
		tst r1         #пока в "руке" остаются камни по одному кладем в след. лунку
	stays gt 
		jsr PUT_SEED   #положили камень в след. лунку
		dec r1         #в руке остался N-1 камень
	wend               #в r3 лежит номер последней ямки, куда клали камень

	jsr CHECK_FOR_SPECIAL_RULE
	
	ldi r0, 0x12   #прекращаем посылать какие-либо сообщения в игру
	ldi r1, 0x00
	st r0, r1
br BANK_SWITCH


### Функция проверяет условия для работу правила Repeat и Capture.
### Если сработало правило Repeat ход остается за нынешним игроком и на этом все. 
### Если оно не сработало проверяется базовое условие для Capture - попал ли последний
### камень в нашу лунку. Если да, то запускаем функцию для дальнейшей работы над Capture
CHECK_FOR_SPECIAL_RULE:
	ldi r2, 0x00      #запустим проверку положили ли посл. камень в нашу манкалу
	jsr ONES_MANCALA  #в r0 загрузили номер нашей манкалы
	if 
		cmp r3, r0
	is ne             #если не в нашу манкалу
		ldv 0x13, r1  #проверка - чей ход
		if            #для каждого случаю подготовим почву - проверить
			dec r1    #был ли положен последний камень в нашу лунку
		is z   #AI
			ldi r2, 0x08   
			sub r3, r2    
		else   #User
			move r3, r2
			sub r0, r2
		fi
		
		if             
			tst r2  #проверяем в чью лунку мы положили посл.камень
		is gt       #если в нашу лунку
			jsr CAPTURE_SEEDS  #если были выполнены условия для Capture - перложим камни
		fi
		jsr PASS_TURN  #передаём ход противнику
	fi
rts


### Функция определяет номер лунки, из которой был сделан ход. Затем она
### "достает все камни из лунки", (в лунке остается 
### значение ноль), и сохраняет эти камни "в руке" (в r1)
LOAD_SEEDS_FROM_SELECTED_HOLE:
	ldv 0x13, r0       #в r0 загрузили спец.значение (1 или 2) чей сейчас ход
	if 
		dec r0         #проверяем чей ход
	is z               #AI
		ldi r0, 0x14   #загрузили номер лунки которую выбрал AI
	else               #User
		ldi r0, 0x15   #загрузили номер лунки которую выбрал User
 	fi	               #в r1 лежит кол-во камней, которые достали из лунки

	ld r0, r3     #загрузили номер лунки из которой сделан ход в r3
	ld r3, r1     #загрузили кол-во камней из лунки в r1
	ldi r2, 0x00
	st r0, r2     #ход был сделан - обнулили номер лунки
	st r3, r2     #достали все камни из лунки (там ничего не осталось)
rts
              

### Функция, которая в r0 загружает номер нужной манкалы (т.е. манкалы текущего игрока 
### или его противника). Если перед вызовом этой функции в r2 лежит значение 0x00,
### то она веренет номер "нашей" манкалы, если 0x08 - номер манкалы врага.
ONES_MANCALA: 
	ldv 0x13, r0      #в r0 загрузили спец.значение (1 или 2) чей сейчас ход
	if                
		dec r0        #проверяем значене r0 и грузим нужную манкалу
	is z
		ldi r0, 0x0F  #для AI
	else
		ldi r0, 0x07  #для User
	fi                #флаг r2: если 0 - наша манкала, 1 - чужая
	xor r2, r0		  #в r0 загрузили номер нужной манкалы 
rts


### Функция для перекладывания одного камня в следующую лунку.
### В r3 должен быть номер текущей лунки. Функиця проверяет допустимо ли 
### класть камень в следующую лунку, и если да - то переходит к
### этой лунке и кладет добавляет туда камень, если нет - пропускает лунки
### до тех пор, пока не найдет первую допустимую. В r3 отсаётся номер лунки
### в которую только что пложили камень.
PUT_SEED:
	ldi r2, 0x0F          #проверяем ушли ли мы дальше лунок и манкал 
	if 
		cmp r3, r2
	is pl
		ldi r3, 0x01      #возвращаемся на первую лунку
	else 
		ldi r2, 0x07      #проверяем находимся ли мы на средней манкале
		if              
			cmp r2, r3   
		is eq 
			ldi r3, 0x09  #переходим на перувую лунку робота
		else
			inc r3        #просто переходим к след. ямке
		fi
	fi
	
	if                #проверяем перешли ли мы к манкале противника
		cmp r3, r0
	is eq             #если да:
		jsr PUT_SEED  #просто пропускаем это яму и идём к след.
	else              #иначе:
		ld r3, r2     #кладем в r2 все камни из нынешней ямы
		inc r2        #добавляем в r2 один камень
		st r3, r2     #полжили камни обратно в ямку
	fi	
rts


### Функиция сначала проверяет выполняются ли условия для работы правила Capture.
### Если все условия выполнены, то из лунки противника захватываются камни 
### (т.е. эта лунка обнуляется, ее значение сохраняется), из лунки игрока тоже 
### захватывается камень (все аналогично противнику) и камни переносятся в манкалу 
### игрока (добавляется N к прежнему значению). Если хотя бы одно условие для Capture
### не было выполнено, то функция прекращает свою работу.
CAPTURE_SEEDS:
	ld r3, r2      #загрузили в r2 кол-во камней в посл.лунке  
	if             #проверяем была ли лунка пуста до того, как положили камень
		dec r2 
	is z             #если она была пуста
		move r3, r2  #в r2 лежит последняя лунка
		if 
			tst r1        #проверка чей ход
		is nz             #User
			ldi r0, 0x0F
		fi
		sub r0, r2     #получили в r2 номер противоположную лунку
		ld r2, r0      #в r0 кол-во камней в протовоположной лунке
		if             #смотрим есть ли там камни
			tst r0   
		is gt          #перекладываем камни из чужой и нашей ячейки в нашу манкалу
			push r0       #сохранили кол-во камней провополож.лунки в стэке
			ldi r0, 0x00  
			st r2, r0     #занулили протовополож.лунку
			if 
				tst r1        #если сейчас ход User-а 
			is nz             #возвращаем номер нашей манкалы в r0
				ldi r0, 0x07  #манкала User-а
			else 
				ldi r0, 0x0F  #манкала AI
			fi
			ld r0, r2     #загрузили в r2 кол-во каменей из нашей манкалы   
			pop r1        #в r1 лежит кол-во камней из противополож.лунки
			add r2, r1    #добавили кол-во камней из нашей манкалы в кучу
			inc r1        #добавили камень из нашей лунки
			ldi r2, 0x00  
			st r3, r2     #занулили кол-во камней в посл.лунке
            st r0, r1     #положили в манкалу Captured камни
		fi						
	fi
rts


### Функция, которая предназначена для того, чтобы передавать очередь хода
### (т.е. обозначать в спец. ячейки памяти RAM, кто будтет должен ходить после).
### По сути в 0x13 просто менятся значение с 1 на 2, с 2 на 1
PASS_TURN:
	ldi r3, 0x01 
	ldi r1, 0x13  
	ld r1, r2     #загрузили в r2 чей сейчас ход
	dec r2         
	xor r2, r3    #поменяли 0 на 1 / 1 на 0
	inc r3        #получили номер другого игрока   
	st r1, r3     #загрузили по адресу 0x13 игрока, который ходит теперь
rts


### Инструкция [asect] используется для указания того, с какого места в памяти ROM
### должны быть сохранены инструкции нижеследующего хода. Мы сохраняем инструкции 
### функции по переключению с одного банка памяти на другой в самом конце памяти, 
### чтобы в Logisim-части происходило безопасное переключение с одного банка памяти 
### на другой. (*Это связано с тем как работает Cdm-8 в Logisim)
asect 0xFA
BANK_SWITCH:  
	ldi r0, 0x11
	ldi r1, 0x00  #переходим на программу Main - она должна проверить окончание игры	
	st r0, r1
	
end