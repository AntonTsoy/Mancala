asect 0x00

### Функция принимеат превым аргументом регистр с номер данной лунки.
### По окончании работа во второй аргумент (регистр) она записывает
### расстояние от этой лунки до манкалы
macro DISTANCE_TO_MANCALA/2
	move $1, $2   #в ПЕРВОМ должен быть номер текущей лунки
	push $1       
    ldi $1, 0x0F  
	sub $1, $2    #теперь во ВТОРОМ лежит расстояние от лунки до манкалы
	pop $1
mend


### Функция для перебора возможных ходов робота (жадная стратегия).
### По окнчании перебора передаем для Make Move лучший 
### ход, полученный на данной глубине вычислений
ENUMERATE_HOLES:
	ldi r0, 0x12   #оставили сообщение в игре, что идет вычисление лучшего хода
	ldi r3, 0x10
	st r0, r3
	
	ldi r0, 0x1B   #в ячейку, хранящую текущ. макс. прирост в манкале
	ldi r3, 0xFF   #записали начальное значение (-1)
	st r0, r3

	ldi r0, 0x0E    #в r0 сохранили адрес последней лунки робота (с нее начинаем перебор)
	ldi r3, 0x08    #до тех пор, пока r0 меньше r3 - проводим перебор
	while           #то есть проходим все лунки робота
 		cmp r0, r3   
	stays gt 
		ld r0, r2    #в r2 кол-во камней из текущ. лунки
		if           #Если в ней нет камней, то симуляция бессмыслена
			tst r2   #Проверка на наличие камней в лунке
		is gt        #Если в лунке есть камни - ход возможен
			push r3
			jsr SIMULATE_MOVE      #симулируем ход из текущей лунки
			ldv 0x1A, r1           #загрузили в r1 флаг: делать ли ход прямо сейчас?
			if 
				tst r1
			is z                   #продолжаем перебор возможных ходов
				jsr COMPARE_MOVES
			else                   #делаем ход прямо сейчас
				ldi r1, 0x1C       #для ячеку [Лунка с макс. прирост.] записали данную лунку
				st r1, r0
				ldi r1, 0x1A       #обнуляем флаг
				ldi r2, 0x00
				st r1, r2
				break
			fi
			pop r3
		fi
		dec r0     #переходим к следующей лунке робота
	wend
	
	ldi r0, 0x1C   #отсавляем запись для Move Maker из какой лунки нужно ходить
	ld r0, r3
	ldi r1, 0x14
	st r1, r3
	
	ldi r2, 0x00   #обнуляем все флаги для вычислений Deep Purple
	st r0, r2
	ldi r1, 0x19
	st r1, r2
	ldi r1, 0x1B
	st r1, r2
br BANK_SWITCH     #вызывем функцию для переключения исполняемой программы 
	
	
### Как бы симулируем ход из данной лунки. Смотрим, куда упадет последний камень.
###	Какой прирост будет в манкале? Сработает ли одно из специальных правил?
SIMULATE_MOVE:
	ldi r1, 0x0D        #Если в лунке лежит больше 13 камней, то правило Capture
	if                  #точно в игре не сработает (это знание приходит с опытом игры
		cmp r1, r2      #в манкалу). Поэтому мы сравниваем текущ кол-во камней с 13-ю
	is ge               #Если камней в лунке меньше или равно 13
    	DISTANCE_TO_MANCALA r0, r1    #в r1 лежит расстояние от лунки до манкалы
		if                  #проверяем кол-во камней в лунке превосходит расстояние до
			sub r2, r1      #манкалы или нет.(*В r1 кол-во камней в руке после манкалы)
		is gt               #Если камни перевалят через манкалу
			ldi r3, 0x06 
			if              #Проверяем: пройдем ли мы все лунки противника?
				sub r1, r3    #В r3 лежит число = r1 - кол-во лунок противника  
			is gt             #Если вернемся к нашим лункам (REPEAT уже не сработает!)
				ldi r1, 0x08
				add r1, r3    #в r3 номер до какой своей лунки мы дойдем
				if 	
					cmp r0, r3
				is eq
					ldi r2, 0x0F	
					sub r2, r3    #В ПЕРВОМ номер лунки напротив
					ld r3, r2     #Во ВТОРОМ кол-во камней из лунки напротив
					inc r2
					inc r2        #На такое число увеличится значение в манкале
					ldi r3, 0x19 
					st r3, r2     #Бросили флаг, что CAPTURE срабатывало
					ldi r3, 0x1D
					st r3, r2
				else 
					ld r3, r1
					if 
						tst r1
					is z
						ldi r2, 0x0F	
						sub r2, r3    #В ПЕРВОМ номер лунки напротив
						ld r3, r2     #Во ВТОРОМ кол-во камней из лунки напротив
			            inc r2
						inc r2        #На такое число увеличится значение в манкале
						ldi r3, 0x19 
						st r3, r2     #Бросили флаг, что CAPTURE срабатывало
						ldi r3, 0x1D
						st r3, r2
					else 
						ldi r1, 0x1D
						ldi r2, 0x01
						st r1, r2
					fi		
				fi					
			else        
				ldi r1, 0x1D
				ldi r2, 0x01
				st r1, r2
			fi
		else       #Если не можем перейти через макалу
		    if    
				tst r1
			is z  
				ldi r1, 0x01
				jsr REPEAT_RULE
			else             #Если камней до манкалы не хватит. Проверим на Capture
				add r0, r2   #В r2 номер лунки, куда упадет последний камень
				ld r2, r1
				if 
					tst r1
				is z
					ldi r1, 0x0F	
					sub r1, r2    #В ПЕРВОМ номер лунки напротив
					ld r2, r1     #Во ВТОРОМ кол-во камней из лунки напротив
					if 
						tst r1
					is nz             #Если в лунке напротив есть камни
						inc r1        #На такое число увеличится значение в манкале
						ldi r2, 0x19 
						st r2, r1     #Бросили флаг, что CAPTURE срабатывало
					fi
					ldi r3, 0x1D
					st r3, r1
				fi
			fi 
		fi	
	else                             #Если камней в лунке больше, чем 13
    	DISTANCE_TO_MANCALA r0, r3   #в r3 лежит расстояние от лунки до манкалы
		sub r2, r3                   #в r3 сколько камней осталось после манкалы
		push r0
		ldi r0, 0x01                 #в r0 счетчик сколько камней добавится в манкалу 
		while              #считаем циклом сколько раз мы перейдем через манкалу
			sub r3, r1
		stays gt
			inc r0         
			move r1, r3    
			ldi r1, 0x0D   
		wend               #в r0 кол-во камней увеличения манкалы
		if
			tst r3
		is z
			move r0, r1    #в r1 кол-во камней увеличения манкалы
			pop r0
			jsr REPEAT_RULE
		else
			ldi r3, 0x1D   
			st r3, r0
			pop r0
		fi
	fi
rts	


### Функция проверяющая были ли в прошлых проверках ходов такие
### которые приводили к Capture. Если таких не было функция дает 
### сигнал о том, что ход нужно делать прямо сейчас. Она вызывается 
### тогда, когда есть условия для правила Repeat
REPEAT_RULE:
	ldv 0x19, r2
	if 
		tst r2
	is z
		ldi r2, 0x1A
		st r2, r0
	else
	 	inc r1
		inc r1
		ldi r2, 0x1D
		st r2, r1
	fi	
rts


### Фнкция для сравнения прошедшего хода с максимальным приростом
### камней в манкале с приростом от текущего хода.
### Если последний даёт больше прироста - максимум обновляется
COMPARE_MOVES:
	ldv 0x1D, r1
	ldi r2, 0x1B
	ld r2, r3
	if
		cmp r1, r3
	is gt
		st r2, r1
		ldi r1, 0x1C
		st r1, r0
	fi
	ldi r1, 0x1D
	ldi r2, 0x00
	st r1, r2
rts


### Инструкция [asect] используется для указания того, с какого места в памяти ROM
### должны быть сохранены инструкции нижеследующего хода. Мы сохраняем инструкции 
### функции по переключению с одного банка памяти на другой в самом конце памяти, 
### чтобы в Logisim-части происходило безопасное переключение с одного банка памяти 
### на другой. (*Это связано с тем как работает Cdm-8 в Logisim)
asect 0xFA         #сохраняем эту функцию в самом конце памяти, чтобы после 
BANK_SWITCH:       #ее выполнения счетчик PC обновился на 0 (команды будут выполняться с начала)
	ldi r0, 0x11       
	ldi r1, 0x03
	st r0, r1      #переключаемся на программу Move Maker
end